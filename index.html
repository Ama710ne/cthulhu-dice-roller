<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>æ–°ãƒ»ã‚¯ãƒˆã‚¥ãƒ«ãƒ•ç¥è©±TRPG ãƒ€ã‚¤ã‚¹ãƒ­ãƒ¼ãƒ©ãƒ¼ v7.7</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  body{background:#0f172a;color:#e2e8f0;font-family:system-ui;padding:18px}
  .success{color:#22c55e;text-shadow:0 0 6px #22c55e}
  .failure{color:#ef4444;text-shadow:0 0 6px #ef4444}
  .critical{color:#3b82f6;font-weight:700;text-shadow:0 0 10px #60a5fa}
  .fumble{color:#f97316;font-weight:700;text-shadow:0 0 8px #fb923c}
  .special{color:#8b5cf6;font-weight:700;text-shadow:0 0 8px #a78bfa}
  .hard{color:#facc15;font-weight:700;text-shadow:0 0 8px #fde047}
  #inline-value{font-size:3rem;font-weight:900}
  #inline-text{font-size:1rem;color:#94a3b8}
  #memo-toggle{position:fixed;top:14px;right:14px;z-index:1200;display:none;background:#111827;padding:8px;border-radius:8px;cursor:pointer}
  .memo-overlay{position:fixed;inset:0;display:none;align-items:flex-start;justify-content:center;z-index:1100}
  .memo-backdrop{position:absolute;inset:0;background:rgba(0,0,0,0.6)}
  .memo-panel{position:relative;margin-top:6vh;width:calc(100% - 40px);max-width:900px;background:#071026;border-radius:8px;padding:12px;transform:translateY(-140%);transition:transform .28s}
  .memo-overlay.show .memo-panel{transform:translateY(0)}
  .memo-textarea{width:100%;min-height:48vh;background:#071026;color:#e2e8f0;border:1px solid rgba(255,255,255,0.04);padding:10px;border-radius:6px;resize:vertical}
  .btn {padding:6px 10px;border-radius:6px}
  /* ä¸‹éƒ¨ãƒãƒŠãƒ¼ï¼ˆéƒ¨å±‹å‰Šé™¤é€šçŸ¥ï¼‰ */
  #delete-banner{position:fixed;left:50%;transform:translateX(-50%);bottom:22px;background:#b91c1c;color:white;padding:10px 18px;border-radius:8px;display:none;z-index:1300;box-shadow:0 6px 18px rgba(0,0,0,0.4)}
</style>
</head>
<body>
  <h1 class="text-2xl font-bold mb-4">æ–°ãƒ»ã‚¯ãƒˆã‚¥ãƒ«ãƒ•ç¥è©±TRPG ãƒ€ã‚¤ã‚¹ãƒ­ãƒ¼ãƒ©ãƒ¼ v7.7</h1>

  <!-- ãƒ­ãƒ“ãƒ¼ -->
  <section id="lobby" class="mb-4 space-y-3">
    <div><label>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åï¼š</label><input id="player-name" class="rounded bg-slate-800 px-3 py-2" placeholder="PL_åå‰"></div>
    <div style="display:flex;gap:8px;align-items:center">
      <div><label>éƒ¨å±‹IDï¼š</label><input id="room-id" class="rounded bg-slate-800 px-3 py-2" placeholder="ä¾‹: ABC123"></div>
      <div><label style="opacity:.8">ï¼ˆKP: ä»»æ„ã§æŒ‡å®šã€ç©ºãªã‚‰è‡ªå‹•ï¼‰</label></div>
    </div>
    <div><label>KPãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼š</label><input id="kp-password" type="password" class="rounded bg-slate-800 px-3 py-2"></div>
    <div class="space-x-2">
      <button id="create-room" class="bg-green-600 btn">éƒ¨å±‹ã‚’ä½œæˆ</button>
      <button id="join-room" class="bg-blue-600 btn">éƒ¨å±‹ã«å‚åŠ </button>
    </div>
    <div id="lobby-msg" class="text-sm text-slate-400"></div>
  </section>

  <!-- ãƒ¡ã‚¤ãƒ³ -->
  <section id="main" class="hidden">
    <div class="flex justify-between items-center mb-4">
      <div>
        <strong>æ¢ç´¢è€…ï¼š</strong>
        <select id="char-select" class="bg-slate-800 px-2 py-1 rounded text-sm"></select>
        <strong class="ml-3">ãƒ¢ãƒ¼ãƒ‰ï¼š</strong><span id="mode-indicator">PL</span>
        <strong class="ml-3">éƒ¨å±‹IDï¼š</strong><span id="room-display" class="text-yellow-400 font-mono">---</span>
      </div>
      <div class="space-x-2">
        <input id="change-room-input" placeholder="æ–°ID" class="hidden bg-slate-800 px-2 py-1 rounded text-sm w-28">
        <button id="change-room-btn" class="hidden bg-indigo-600 btn text-sm">IDå¤‰æ›´</button>
        <button id="delete-room" class="hidden bg-red-700 btn text-sm">éƒ¨å±‹å‰Šé™¤</button>
        <button id="exit-room" class="bg-gray-700 btn text-sm">é€€å‡º</button>
      </div>
    </div>

    <div class="mb-3">
      <label>æ¢ç´¢è€…JSONï¼ˆè¤‡æ•°å¯ï¼‰ï¼š</label>
      <input id="char-file" type="file" accept=".json" multiple class="bg-slate-800 px-3 py-2 rounded">
    </div>

    <div id="status-section" class="mb-4">
      <h2 class="font-bold mb-1">ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼ˆç·¨é›†å¯ï¼‰</h2>
      <div id="status-grid" class="grid grid-cols-2 sm:grid-cols-3 gap-2 mb-2"></div>
      <div class="text-red-400 font-semibold text-lg">HPï¼š<span id="hp-display">--</span></div>
      <div class="mt-2">
        <input id="hp-input" type="number" class="w-24 bg-slate-800 px-2 py-1 rounded" placeholder="HPã‚’å¤‰æ›´">
        <button id="update-hp" class="bg-blue-500 btn">å¤‰æ›´</button>
      </div>
    </div>

    <div id="skills-section" class="mb-4">
      <h2 class="font-bold mb-2">æŠ€èƒ½ãƒ»èƒ½åŠ›ä¸€è¦§</h2>
      <div id="skill-buttons" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2 overflow-auto max-h-[36vh]"></div>
    </div>

    <div class="mb-4">
      <label>ä¿®æ­£å€¤ï¼š</label>
      <input id="modifier" type="number" value="0" class="w-24 bg-slate-800 px-2 py-1 rounded">
      <label class="ml-4"><input id="private-roll" type="checkbox" class="mr-1">ç§˜åŒ¿ãƒ€ã‚¤ã‚¹</label>
    </div>

    <div class="mb-6">
      <button id="roll-btn" class="bg-yellow-500 btn font-bold">è‡ªç”±ãƒ€ã‚¤ã‚¹ã‚’æŒ¯ã‚‹</button>
      <input id="expr" placeholder="ä¾‹ï¼š3d6+1d4-2" class="ml-2 bg-slate-800 px-3 py-2 rounded w-48">
    </div>

    <div id="inline-result" class="text-center mb-4">
      <div id="inline-value">--</div>
      <div id="inline-text">ã“ã“ã«çµæœãŒè¡¨ç¤ºã•ã‚Œã¾ã™</div>
    </div>

    <div>
      <h3 class="font-bold mb-2">å±¥æ­´</h3>
      <div id="history" class="space-y-1 max-h-[40vh] overflow-y-auto text-sm"></div>
    </div>
  </section>

  <button id="memo-toggle">ğŸ“ ãƒ¡ãƒ¢</button>
  <div id="memo-overlay" class="memo-overlay">
    <div class="memo-backdrop" id="memo-backdrop"></div>
    <div class="memo-panel">
      <div style="display:flex;justify-content:space-between;align-items:center;padding-bottom:8px;">
        <strong>ãƒ¡ãƒ¢ï¼ˆå€‹äººç”¨ï¼‰</strong>
        <div><button id="memo-close" class="bg-slate-700 btn">âœ–</button></div>
      </div>
      <textarea id="memo-text" class="memo-textarea" placeholder="ã“ã“ã«ãƒ¡ãƒ¢ã‚’ä¿å­˜ã—ã¾ã™ï¼ˆè‡ªå‹•ä¿å­˜ã•ã‚Œã¾ã™ï¼‰"></textarea>
    </div>
  </div>

  <div id="delete-banner">âš ï¸ KPãŒã“ã®éƒ¨å±‹ã‚’å‰Šé™¤ã—ã¾ã—ãŸ</div>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

  <script>
  document.addEventListener("DOMContentLoaded", () => {
    // --- Firebase è¨­å®šï¼ˆãã®ã¾ã¾ï¼‰ ---
    const firebaseConfig = {
      apiKey: "AIzaSyBrfXedwhmcCGYWrNaCJTN7xgTJUTqwwG0",
      authDomain: "daisurora.firebaseapp.com",
      databaseURL: "https://daisurora-default-rtdb.firebaseio.com",
      projectId: "daisurora",
      storageBucket: "daisurora.firebasestorage.app",
      messagingSenderId: "998058550723",
      appId: "1:998058550723:web:44b5fa8f1eba105f15c976"
    };
    try{ firebase.initializeApp(firebaseConfig); } catch(e){}
    const db = firebase.database();

    // DOM
    const createBtn = document.getElementById("create-room");
    const joinBtn = document.getElementById("join-room");
    const deleteRoomBtn = document.getElementById("delete-room");
    const exitBtn = document.getElementById("exit-room");
    const changeRoomInput = document.getElementById("change-room-input");
    const changeRoomBtn = document.getElementById("change-room-btn");
    const playerName = document.getElementById("player-name");
    const kpPassword = document.getElementById("kp-password");
    const roomIdInput = document.getElementById("room-id");
    const lobby = document.getElementById("lobby");
    const main = document.getElementById("main");
    const lobbyMsg = document.getElementById("lobby-msg");
    const modeIndicator = document.getElementById("mode-indicator");
    const roomDisplay = document.getElementById("room-display");
    const charFile = document.getElementById("char-file");
    const charSelect = document.getElementById("char-select");
    const statusGrid = document.getElementById("status-grid");
    const skillButtons = document.getElementById("skill-buttons");
    const hpDisplay = document.getElementById("hp-display");
    const hpInput = document.getElementById("hp-input");
    const updateHpBtn = document.getElementById("update-hp");
    const modifierInput = document.getElementById("modifier");
    const privateCheck = document.getElementById("private-roll");
    const rollBtn = document.getElementById("roll-btn");
    const exprInput = document.getElementById("expr");
    const inlineValue = document.getElementById("inline-value");
    const inlineText = document.getElementById("inline-text");
    const historyDiv = document.getElementById("history");
    const memoToggle = document.getElementById("memo-toggle");
    const memoOverlay = document.getElementById("memo-overlay");
    const memoClose = document.getElementById("memo-close");
    const memoBackdrop = document.getElementById("memo-backdrop");
    const memoText = document.getElementById("memo-text");
    const deleteBanner = document.getElementById("delete-banner");

    // state
    let roomId = null;
    let isKP = false;
    let listener = null;
    let deleteWatcher = null;
    let currentChars = {}; // name -> object
    let currentCharName = null;
    const playerId = "id_" + Math.random().toString(36).slice(2,10);

    // helpers
    function showStatus(msg){ lobbyMsg.textContent = msg; }
    async function sha256Hex(str){
      if(window.crypto && crypto.subtle){
        const buf = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(str));
        return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
      } else {
        let h=0; for(let i=0;i<str.length;i++) h=(Math.imul(31,h)+str.charCodeAt(i))|0;
        return (h>>>0).toString(16);
      }
    }

    // ---- room create ----
    createBtn.onclick = async () => {
      const pw = kpPassword.value.trim();
      if(!pw) return showStatus("KPãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
      const name = playerName.value.trim() || "KP";
      const idCand = (roomIdInput.value.trim() || Math.random().toString(36).slice(2,8)).toUpperCase();
      try {
        const snap = await db.ref("rooms/"+idCand+"/meta").get();
        if(snap.exists() && !snap.val().deleted) {
          return showStatus("ãã®éƒ¨å±‹IDã¯ã™ã§ã«ä½¿ç”¨ä¸­ã§ã™ã€‚åˆ¥ã®IDã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚");
        }
        const hash = await sha256Hex(pw);
        await db.ref("rooms/"+idCand+"/meta").set({kpName:name,passwordHash:hash,createdAt:Date.now(),deleted:false});
        roomId = idCand; isKP = true;
        enterRoom();
        pushSystem(`${playerName.value.trim()||"åŒ¿å"} ãŒå‚åŠ ã—ã¾ã—ãŸã€‚`);
      } catch(e){
        console.error(e); showStatus("éƒ¨å±‹ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ");
      }
    };

    // ---- room join ----
    joinBtn.onclick = async () => {
      const id = (roomIdInput.value.trim()||"").toUpperCase();
      if(!id) return showStatus("éƒ¨å±‹IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
      try {
        const snap = await db.ref("rooms/"+id+"/meta").get();
        if(!snap.exists()) return showStatus("éƒ¨å±‹ãŒå­˜åœ¨ã—ã¾ã›ã‚“");
        if(snap.val().deleted) return showStatus("ã“ã®éƒ¨å±‹ã¯å‰Šé™¤æ¸ˆã¿ã§ã™");
        const input = kpPassword.value.trim();
        if(input){
          const hash = await sha256Hex(input);
          isKP = (hash === snap.val().passwordHash);
        } else isKP = false;
        roomId = id;
        enterRoom();
        pushSystem(`${playerName.value.trim()||"åŒ¿å"} ãŒå‚åŠ ã—ã¾ã—ãŸã€‚`);
      } catch(e){
        console.error(e); showStatus("å‚åŠ ã«å¤±æ•—ã—ã¾ã—ãŸ");
      }
    };

    // ---- enter room common ----
    function enterRoom(){
      lobby.classList.add("hidden");
      main.classList.remove("hidden");
      roomDisplay.textContent = roomId || '---';
      modeIndicator.textContent = isKP ? "KP" : "PL";
      memoToggle.style.display = "block";
      // KP-only controls
      if(isKP){
        deleteRoomBtn.classList.remove("hidden");
        changeRoomInput.classList.remove("hidden");
        changeRoomBtn.classList.remove("hidden");
      } else {
        deleteRoomBtn.classList.add("hidden");
        changeRoomInput.classList.add("hidden");
        changeRoomBtn.classList.add("hidden");
      }
      loadMemo();
      watchDeletion();   // watch deleted flag
      listenRoom();      // listen rolls
      showStatus("éƒ¨å±‹ã«å…¥ã‚Šã¾ã—ãŸ: " + roomId);
    }

    // ---- exit room ----
    exitBtn.onclick = () => {
      pushSystem(`${playerName.value.trim()||"åŒ¿å"} ãŒé€€å‡ºã—ã¾ã—ãŸã€‚`);
      exitRoom();
    };
    function exitRoom(){
      if(listener && roomId) db.ref("rooms/"+roomId+"/rolls").off("child_added", listener);
      if(deleteWatcher && roomId) db.ref("rooms/"+roomId+"/meta/deleted").off("value", deleteWatcher);
      listener = null; deleteWatcher = null;
      roomId = null; isKP = false;
      main.classList.add("hidden");
      lobby.classList.remove("hidden");
      memoToggle.style.display = "none";
      showStatus("é€€å‡ºã—ã¾ã—ãŸ");
    }

    // ---- delete room (KP only) ----
    deleteRoomBtn.onclick = async () => {
      if(!isKP || !roomId) return alert("KPã®ã¿ãŒå‰Šé™¤ã§ãã¾ã™ã€‚");
      if(!confirm("ã“ã®éƒ¨å±‹ã‚’å®Œå…¨ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿï¼ˆå…¨å“¡ãŒãƒ­ãƒ“ãƒ¼ã«æˆ»ã‚Šã¾ã™ï¼‰")) return;
      try {
        // set deleted flag first so clients can show banner
        await db.ref("rooms/"+roomId+"/meta/deleted").set(true);
        // small delay to allow watchers to see flag, then remove node
        setTimeout(async ()=>{
          try{ await db.ref("rooms/"+roomId).remove(); }catch(e){console.error("remove failed",e);}
        }, 300);
        // local exit
        exitRoom();
      } catch(e){
        console.error(e); alert("å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ");
      }
    };

    // ---- watch deletion to show banner on PL side ----
    function watchDeletion(){
      if(!roomId) return;
      deleteWatcher = snap => {
        if(snap.exists() && snap.val() === true){
          // show bottom-center red banner for 5s
          deleteBanner.style.display = "block";
          setTimeout(()=>{ deleteBanner.style.display = "none"; }, 5000);
          // force back to lobby after short delay
          setTimeout(()=>{ exitRoom(); showStatus("KPãŒéƒ¨å±‹ã‚’å‰Šé™¤ã—ã¾ã—ãŸ"); }, 600);
        }
      };
      db.ref("rooms/"+roomId+"/meta/deleted").on("value", deleteWatcher);
    }

    // ---- change room id (KP) ----
    changeRoomBtn.onclick = async () => {
      if(!isKP || !roomId) return alert("KPã®ã¿å¤‰æ›´ã§ãã¾ã™");
      const newId = (changeRoomInput.value || "").trim().toUpperCase();
      if(!newId) return alert("æ–°ã—ã„éƒ¨å±‹IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
      if(newId === roomId) return alert("åŒã˜IDã§ã™");
      try {
        const exist = await db.ref("rooms/"+newId+"/meta").get();
        if(exist.exists() && !exist.val().deleted) return alert("ãã®IDã¯æ—¢ã«ä½¿ã‚ã‚Œã¦ã„ã¾ã™");
        // copy entire room node and remove old
        const roomDataSnap = await db.ref("rooms/"+roomId).get();
        if(!roomDataSnap.exists()) return alert("å…ƒã®éƒ¨å±‹ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
        const roomData = roomDataSnap.val();
        await db.ref("rooms/"+newId).set(roomData);
        await db.ref("rooms/"+roomId).remove();
        roomId = newId;
        roomDisplay.textContent = roomId;
        showStatus("éƒ¨å±‹IDã‚’å¤‰æ›´ã—ã¾ã—ãŸ: " + roomId);
        // reattach listeners
        if(listener) db.ref("rooms/"+roomId+"/rolls").off("child_added", listener);
        if(deleteWatcher) db.ref("rooms/"+roomId+"/meta/deleted").off("value", deleteWatcher);
        listenRoom();
        watchDeletion();
      } catch(e){
        console.error(e); alert("éƒ¨å±‹IDå¤‰æ›´ã«å¤±æ•—ã—ã¾ã—ãŸ");
      }
    };

    // ---- push system message to history + (if in room) to DB ----
    function pushSystem(text){
      const payload = { system:true, text, timestamp: Date.now() };
      addHistory(payload);
      if(roomId) db.ref("rooms/"+roomId+"/rolls").push(payload);
    }

    // ---- Character JSON handling (multiple) ----
    charFile.onchange = e => {
      const files = Array.from(e.target.files || []);
      for(const f of files){
        const r = new FileReader();
        r.onload = ev => {
          try {
            const data = JSON.parse(ev.target.result);
            addCharacter(data);
          } catch(err){
            alert("JSONèª­ã¿è¾¼ã¿å¤±æ•—: " + f.name);
          }
        };
        r.readAsText(f);
      }
      e.target.value = "";
    };

    function addCharacter(ch){
      const name = ch.ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼å || ch.name || ("æ¢ç´¢è€…" + (Object.keys(currentChars).length+1));
      currentChars[name] = ch;
      refreshCharSelect(name);
    }

    function refreshCharSelect(selectName){
      charSelect.innerHTML = "";
      Object.keys(currentChars).forEach(n=>{
        const opt = document.createElement("option"); opt.value = n; opt.textContent = n;
        charSelect.appendChild(opt);
      });
      if(selectName) currentCharName = selectName;
      else if(!currentCharName) currentCharName = Object.keys(currentChars)[0] || null;
      if(currentCharName) charSelect.value = currentCharName;
      renderCharacter(currentCharName);
    }

    charSelect.onchange = ()=>{ currentCharName = charSelect.value; renderCharacter(currentCharName); };

    // --- render character (attributes editable, skills buttons) ---
    function renderCharacter(name){
      statusGrid.innerHTML = ""; skillButtons.innerHTML = ""; hpDisplay.textContent="--";
      if(!name || !currentChars[name]) return;
      const ch = currentChars[name];
      // support various keys
      const attributes = ch.ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ || ch.attributes || ch.status || {};
      const skills = ch.æŠ€èƒ½ || ch.skills || ch.skill || {};
      // normalize: if skills contains å¹¸é‹ => move to attributes; ã‚¢ã‚¤ãƒ‡ã‚¢/çŸ¥è­˜ prefer skills
      if(skills["å¹¸é‹"] && !attributes["å¹¸é‹"]){ attributes["å¹¸é‹"] = skills["å¹¸é‹"]; delete skills["å¹¸é‹"]; }
      if(attributes["ã‚¢ã‚¤ãƒ‡ã‚¢"] && !skills["ã‚¢ã‚¤ãƒ‡ã‚¢"]){ skills["ã‚¢ã‚¤ãƒ‡ã‚¢"] = attributes["ã‚¢ã‚¤ãƒ‡ã‚¢"]; delete attributes["ã‚¢ã‚¤ãƒ‡ã‚¢"]; }
      if(attributes["çŸ¥è­˜"] && !skills["çŸ¥è­˜"]){ skills["çŸ¥è­˜"] = attributes["çŸ¥è­˜"]; delete attributes["çŸ¥è­˜"]; }

      // attributes area: editable + roll button
      Object.entries(attributes).forEach(([k,v])=>{
        const wrap = document.createElement("div"); wrap.className="flex items-center space-x-2";
        const label = document.createElement("span"); label.textContent = `${k}ï¼š`;
        const input = document.createElement("input"); input.type="number"; input.value = (v===undefined||v===null)?"":v;
        input.className="w-20 bg-slate-800 rounded px-2 py-1 text-sm";
        input.oninput = ()=> { attributes[k] = parseInt(input.value,10) || 0; updateAutoHp(attributes); };
        const btn = document.createElement("button"); btn.textContent="æŒ¯ã‚‹"; btn.className="bg-slate-700 px-2 py-1 rounded text-sm";
        btn.onclick = ()=> { const useVal = parseInt(input.value,10) || 0; rollSkill(k, useVal); };
        wrap.appendChild(label); wrap.appendChild(input); wrap.appendChild(btn);
        statusGrid.appendChild(wrap);
      });
      updateAutoHp(attributes);

      // skills buttons
      Object.entries(skills).forEach(([k,v])=>{
        const btn = document.createElement("button");
        btn.textContent = `${k} (${v})`;
        btn.className = "bg-slate-700 hover:bg-slate-600 rounded px-2 py-1 text-sm";
        btn.onclick = ()=> rollSkill(k, parseInt(v,10) || 0);
        skillButtons.appendChild(btn);
      });
    }

    function updateAutoHp(attributes){
      const find = (arr)=>{ for(const k of arr) if(attributes[k]!==undefined) return parseInt(attributes[k],10)||0; return 0; };
      const con = find(["CON","Con","con","ï¼£ï¼¯ï¼®"]);
      const siz = find(["SIZ","Siz","siz","ï¼³ï¼©ï¼º"]);
      if(con && siz) hpDisplay.textContent = Math.ceil((con + siz)/10);
      else hpDisplay.textContent = "--";
    }

    updateHpBtn.onclick = ()=>{ const v=parseInt(hpInput.value,10); if(!isNaN(v)) hpDisplay.textContent = v; };

    // --- dice utilities + parse ---
    function rollD(n){ return Math.floor(Math.random()*n)+1; }
    function parseDice(expr){
      expr = (expr||"").replace(/\s+/g,'');
      const parts = expr.match(/([+-]?\d*d\d+|[+-]?\d+)/g);
      if(!parts) return { total: NaN, rolls: [] };
      let total = 0; const rolls = [];
      for(let part of parts){
        let sign = 1;
        if(part.startsWith('-')){ sign=-1; part=part.slice(1); }
        if(part.startsWith('+')) part = part.slice(1);
        if(part.includes('d')){
          const [a,b] = part.split('d'); const count = parseInt(a) || 1; const faces = parseInt(b) || 0;
          const sub = [];
          for(let i=0;i<count;i++){ const r=rollD(faces); sub.push(r); total += r * sign; }
          rolls.push((sign<0?'-':'') + `${count}d${faces}=[${sub.join(',')}]`);
        } else {
          const n = parseInt(part) || 0; total += sign * n; rolls.push((sign<0?'-':'') + String(n));
        }
      }
      return { total, rolls };
    }

    // --- kame-style calc: raw-basedåˆ¤å®š ---
    function calcResult(raw, skillVal){
      const specialExact = Math.ceil(skillVal / 5);
      const hardExact = Math.ceil(skillVal / 2);
      if(raw <= 5) return { status:"ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ï¼", cls:"critical" };
      if((raw >= 96 && skillVal < 100) || raw === 100) return { status:"ãƒ•ã‚¡ãƒ³ãƒ–ãƒ«", cls:"fumble" };
      if(raw === specialExact) return { status:"ã‚¹ãƒšã‚·ãƒ£ãƒ«æˆåŠŸ", cls:"special" };
      if(raw === hardExact) return { status:"ãƒãƒ¼ãƒ‰æˆåŠŸ", cls:"hard" };
      if(raw <= skillVal) return { status:"æˆåŠŸ", cls:"success" };
      return { status:"å¤±æ•—", cls:"failure" };
    }

    // --- rolling ---
    function rollSkill(name, val){
      const raw = rollD(100);
      const mod = parseInt(modifierInput.value,10) || 0;
      const modified = raw + mod;
      const res = calcResult(raw, val); // kame: raw-based
      const now = Date.now();

      inlineValue.textContent = raw;
      inlineText.className = res.cls || "";
      inlineText.textContent = `${name}(${val}) â†’ å‡ºç›®:${raw}${mod?((mod>0?'+':'')+mod):''} = ${modified} â†’ ${res.status}`;

      const payload = {
        player: playerName.value.trim() || "åŒ¿å",
        playerId,
        char: currentCharName || null,
        skill: name,
        val,
        raw,
        mod,
        modified,
        status: res.status,
        cls: res.cls,
        hidden: !!privateCheck.checked,
        timestamp: now
      };

      addHistory(payload);
      if(roomId) db.ref("rooms/"+roomId+"/rolls").push(payload);
    }

    rollBtn.onclick = ()=>{
      const expr = exprInput.value.trim() || "1d100";
      const parsed = parseDice(expr);
      inlineValue.textContent = parsed.total;
      inlineText.className = "";
      inlineText.textContent = `${expr} â†’ ${parsed.rolls.join(', ')} = ${parsed.total}`;
      const payload = {
        player: playerName.value.trim() || "åŒ¿å",
        playerId,
        char: currentCharName || null,
        expr,
        rolls: parsed.rolls,
        total: parsed.total,
        hidden: !!privateCheck.checked,
        timestamp: Date.now()
      };
      addHistory(payload);
      if(roomId) db.ref("rooms/"+roomId+"/rolls").push(payload);
    };

    // --- history display ---
    function addHistory(d){
      const div = document.createElement("div");
      const time = d.timestamp ? new Date(d.timestamp).toLocaleTimeString() : new Date().toLocaleTimeString();
      if(d.system){
        div.innerHTML = `<span class="text-slate-400">[system] ${d.text} <small class="text-slate-500">(${time})</small></span>`;
      } else {
        const who = d.player || 'åŒ¿å';
        const charTxt = d.char ? `ã€${d.char}ã€‘ ` : '';
        const secretBadge = d.hidden ? `<small class="text-slate-500">ï¼ˆç§˜åŒ¿ï¼‰</small>` : '';
        const sameName = (d.player === playerName.value.trim());
        // secret visibility: show if not hidden OR isKP OR sameName
        if(d.hidden && !isKP && !sameName){
          div.innerHTML = `${who}ï¼š${charTxt}${d.skill?d.skill+' â†’ '+(d.status||'') : (d.expr?d.expr : '')} ${secretBadge}<br><small class="text-slate-500">${time}</small>`;
        } else {
          let detail='';
          if(d.raw!==undefined) detail = ` å‡ºç›®:${d.raw}${d.mod?((d.mod>0?'+':'')+d.mod):''}=${d.modified}`;
          else if(d.total!==undefined) detail = ` = ${d.total}`;
          div.innerHTML = `<span class="${d.cls||''}">${who}ï¼š${charTxt}${d.skill?d.skill+' â†’ '+(d.status||'') : (d.expr?d.expr : '')} ${secretBadge}ï¼ˆ${d.modified!==undefined?d.modified:(d.total!==undefined?d.total:d.raw!==undefined?d.raw:'')}ï¼‰<br><small class="text-slate-500">${time}${detail}</small></span>`;
        }
      }
      historyDiv.prepend(div);
    }

    // --- listen firebase room rolls ---
    function listenRoom(){
      if(!roomId) return;
      if(listener) db.ref("rooms/"+roomId+"/rolls").off("child_added", listener);
      listener = snap => {
        const d = snap.val();
        const sameName = d.player && (d.player === playerName.value.trim());
        if(d.system){ addHistory(d); return; }
        if(!d.hidden || isKP || sameName) addHistory(d);
      };
      db.ref("rooms/"+roomId+"/rolls").on("child_added", listener);
    }

    // --- memo saving per player (room-scoped if room present) ---
    function debounce(fn, wait=800){
      let t=null; return (...a)=>{ if(t) clearTimeout(t); t=setTimeout(()=>{ fn(...a); t=null; }, wait); };
    }
    async function loadMemo(){
      memoText.value = "";
      const name = playerName.value.trim() || "åŒ¿å";
      if(!roomId){
        const local = localStorage.getItem(`memo_${name}`);
        if(local) memoText.value = JSON.parse(local).text || "";
        return;
      }
      try {
        const snap = await db.ref(`rooms/${roomId}/notes/${name}`).get();
        if(snap.exists()) memoText.value = snap.val().text || "";
      } catch(e){ console.error(e); }
    }
    const saveMemoNow = async ()=>{
      const name = playerName.value.trim() || "åŒ¿å"; const text = memoText.value;
      if(!roomId){ localStorage.setItem(`memo_${name}`, JSON.stringify({text,at:Date.now()})); return; }
      try{ await db.ref(`rooms/${roomId}/notes/${name}`).set({text,updatedAt:Date.now()}); } catch(e){ console.error(e); }
    };
    const debouncedSave = debounce(saveMemoNow, 1200);
    memoText.addEventListener("input", debouncedSave);
    memoToggle.onclick = ()=>{ memoOverlay.style.display="flex"; memoOverlay.classList.add("show"); setTimeout(()=>memoText.focus(),300); };
    memoClose.onclick = ()=>{ memoOverlay.classList.remove("show"); setTimeout(()=>memoOverlay.style.display="none",300); };
    memoBackdrop.onclick = ()=> memoClose();

    // initial
    showStatus("æº–å‚™å®Œäº†ã€‚éƒ¨å±‹ã‚’ä½œæˆã¾ãŸã¯å‚åŠ ã—ã¦ãã ã•ã„ã€‚");
  });
  </script>
</body>
</html>
